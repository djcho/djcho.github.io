---
title : "[SpringBoot][Chapter2.4] 디자인 패턴"
categories:
- SpringBoot
tag :
- [SpringBoot, Spring, Framework, Java, GoF, DesignPattern]
toc: true
toc_sticky : true
published : true
date : 2022-07-16
last_modified_at : 2022-07-16
---





장정우님이 지음, [스프링부트 핵심가이드 :: 스프링 부트를 활용한 애플리케이션 개발 실무] 책을 읽고 정리한 필기입니다.📢
{: .notice--warning}



## 디자인 패턴

디자인 패턴(Design Pattern)은 소프트웨어를 설계할 때 자주 발생하는 문제들을 해결하기 위해 고안된 해결책이다. 디자인 패턴에서 '패턴'이라는 단어는 애플리케이션 개발에서 발생하는 문제는 유사한 경우가 많고 해결책도 동일하게 적용할 수 있다는 의미를 내포한다. 그러나 디자인 패턴이 모든 문제의 정답은 아니며, 상황에 맞는 최적 패턴을 결정해서 사용하는 것이 바람직하다.



### 디자인 패턴의 종류

디자인 패턴을 구체화해서 정리한 대표적인 분류 방식으로 'GoF 디자의 패턴'이라는 것이 있다. 여기서 GoF는 'Gang of Four'의 줄임말로, 디자인 패턴을 구체화하고 체계화해서 분류한 4명의 인물을 의미한다.

| 생성(Creational) 패턴                                        | 구조(Structural) 패턴                                        | 행위(Behavioral) 패턴                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 추상 팩토리(Adstract Factory)<br />빌더(Builder)<br />팩토리 메서드(Factory Method)<br />프로토타입(Prototype)<br />싱글톤(Singleton) | 어댑터(Adpter)<br />브리지(Bridge)<br />컴포지트(Composite)<br />데코레이터(Decorator)<br />퍼사드(Facade)<br />플라이웨이트(Flyweight)<br />프락시(Proxy) | 책임 연쇄(Chain of Responsibility)<br />커맨드(Command)<br />인터프리터(Interpreter)<br />이터레이터(Iterator)<br />미디에이터(Mediator)<br />메멘토(Memento)<br />옵저버(Observer)<br />스테이트(State)<br />스트레티지(Strategy)<br />템플릿 메서드(Template Method)<br />비지터(Visitor) |

GoF 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴의 총 세 가지로 구분된다.

#### 생성 패턴

- 객체 생성에 사용되는 패턴으로, 객체를 수정해도 호출부가 영향을 받지 않게 한다.

#### 구조 패턴

- 객체를 조합해서 더 큰 구조를 만드는 패턴이다.

#### 행위 패턴

- 객체 간의 알고리즘이나 책임 분배에 관한 패턴이다.
- 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배한다. 결합도 최소화를 고려할 필요가 있다.



### 생성 패턴

- **추상 팩토리** : 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴이다.
- **빌더** : 객체의 생성과 표현을 분리해 객체를 생성하는 패턴이다.
- **팩토리 메서드** : 객체 생성을 서브 클래스로 분리해서 위임하는 패턴이다.
- **프로토타입 **: 원본 객체를 복사해 객체를 생성하는 패턴이다.
- **싱글톤** : 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴이다.



### 구조 패턴

- **어댑터 **: 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴이다.
- **브리지 **: 추상화와 구현을 분리해서 각각 독립적으로 변형케 하는 패턴이다.
- **컴포지트** : 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴이다.
- **데코레이터** : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴이다.
- **퍼사드** : 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴이다.
- **플라이웨이트** : 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 '가상 인스턴스'를 제공할 때 사용하는 패턴이다.
- **프락시** : 특정 객체를 직접 참조하지 않고 해당 객체를 대행(프락시)하는 객체를 통해 접근하는 패턴이다.



### 행위 패턴

- **책임 연쇄** : 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴이다.
- **커맨드** : 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴이다.
- **인터프리터** : 주어진 언어의 문법을 위한 표현 수단으로 정의하고 해당 언어로 구성된 문장을 해석하는 패턴이다.
- **이터레이터** : 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴이다.
- **미디에이터** : 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴이다.
- **메멘토** : 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패턴이다.
- **옵저버** : 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 디자인 패턴이다.
- **스테이트** : 상태에 따라 객체가 행동을 변경하게 하는 패턴이다.
- **스트래티지** : 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴이다.
- **템플릿 메서드** : 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해서 전체 수행 구조는 바꾸지 않으면서 특정 단계만 변경해서 수행하는 패턴이다.
- **비지터** : 실제 로직을 가지고 있는 객체(visitor)가 로직을 적용할 객체(element)를 방문하여 실행하는 패턴이다.

